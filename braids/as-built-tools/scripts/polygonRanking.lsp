;; Defines functions to get and set a property that I am inventing for objects (specifically polygons, and the regions generated from them) called "rank".
;; This 'rank' property will be stored as extended data.
;; The "rank" of polygons is used by my functions that convert polygons into regions.  The rank determines how regions combine.  When you have a set of regions,
;; the rank of each region specifies a way for the regions to be boolean-combined.  The 'rank' proerty lets us flag polygons (and then the regions generated by each of those polygons)
;; as being subtractive or additive.  rank is an integer.
;; Let's call this rank-aware combination of regions rankwiseCombine().
;; rankwiseCombineRegions() takes as an argument a set of regions, and produces as output a single region (not sure yet if the returned region should itself have a rank).
;; rankwiseCombineRegions() reads the rank property (if defined) of each region in the input set.  regions which do not have a specified rank property are assumed to be rank 0.
;; The returned region is constructed as a boolean combination of the input regions as follows:
;; Take the boolean sum of all rank 0 regions.
;; From this subtract all rank 1 regions.
;; To this, add all rank 2 regions.
;; From this, subtract all rank 3 regions.
;; etc. (continue the pattern until all regions in the set have been accounted for.)
;; return the result.
;; By default, a polygon will be regarded as having rank 0. 

;; 2017/01/04 - extending the ranking facility so that a rank is now a list of 0 or more integers, rather than a single integer.

; Registers the application name.

;; (setq thisApplicationName "polygonRanking")  
;; (regapp thisApplicationName)
(regapp "polygonRanking")

(defun getRank
	(
		arg
		/
		theEname
		theEntity
		returnValue
		thisApplicationName
		xData
		xDataGroupCodeForInteger
	)
	(setq thisApplicationName "polygonRanking")
	(setq xDataGroupCodeForInteger 1070)
	(COND 
		(
			(= (type arg) 'ENAME)
			(setq theEname arg)
		)
		(
			(= (type arg) 'VLA-OBJECT)
			(setq theEname 
				(handent (vla-get-Handle arg))
			)
		)
		(
			T
			(princ "error: getRank was passed an argument that was neither an ENAME nor a VLA-OBJECT.")
		)
		
	)
	
	(setq theEntity 
		(entget theEname (list thisApplicationName))
	)
	;; "(assoc -3 theEntity)" evaluates to something like
	;;		(-3 ("polygonRanking" (1070 . 10)))

	
	(if 
		(assoc -3 theEntity) ;; theEntity has some polyGonRanking xdata
		(progn
			; ; (setq returnValue 
				; ; (cdr 
					; ; (assoc xDataGroupCodeForInteger 
						; ; (cdr 
							; ; (nth 0 
								; ; (cdr
									; ; (assoc -3 theEntity)
								; ; )
							; ; )
						; ; )
					; ; )
				; ; )
			; ; )
			
			(setq returnValue
				(mapcar 'cdr 
					(vl-remove-if-not '(lambda (x) (= xDataGroupCodeForInteger (car x))) 
					;(vl-remove-if-not '(lambda (x) (= 1070 (car x))) 
						(cdr
							(cadr
								(assoc -3 theEntity)
							)
						)
					)
				)
			)
		)
		(progn
			;in this case, selectedEntity does not have any existing xData (at least none that we care about)
			;(princ "no exisiting xData found.\n")
			;;(setq returnValue nil)
			(setq returnValue (list 0)) ;; any object that does not have an explicit rank assigned is considered to be rank (0).
		)
	)
	returnValue
)
;==============


(defun setRank
	(
		arg
		newRank
		/
		theEname
		theEntity
		returnValue
		newXData
		thisApplicationName
		xDataGroupCodeForInteger
	)
	(setq thisApplicationName "polygonRanking")
	(setq xDataGroupCodeForInteger 1070)
	
	(COND 
		(
			(= (type arg) 'ENAME)
			(setq theEname arg)
		)
		(
			(= (type arg) 'VLA-OBJECT)
			(setq theEname 
				(handent (vla-get-Handle arg))
			)
		)
		(
			T
			(princ "error: setRank was passed a first argument that was neither an ENAME nor a VLA-OBJECT.")
		)
	)
	
	;; ensure that newRank is a list of integers (this will let us tolerate a single integer being passed as the newRank argument)
	(if (not (listp newRank)) (setq newRank (list newRank)))
	
	(setq newXData                       
		(list 
			-3 
			(append 
				(list thisApplicationName)
				(mapcar '(lambda (x) (cons xDataGroupCodeForInteger x)) newRank)
				; (list
					; (cons xDataGroupCodeForInteger  77)
					; (cons xDataGroupCodeForInteger  88)
					; (cons xDataGroupCodeForInteger  99)
				; )		
			)
		)                               
	)  
	
	(setq theEntity 
		(entget theEname (list thisApplicationName))
	)
	(if (assoc -3 theEntity)
		(progn
			; in this case, theEntity already has some xdata, so we will replace the existing xData with
			; the new xData
			
			;(princ (strcat "existing xData: "))(princ (assoc -3 theEntity))(princ "\n.\n")
			
			(setq theEntity
			  (subst 
				newXData 			;replacement
				(assoc -3 theEntity) 	;needle
				theEntity 				;haystack
			  )
			) 
		)
		(progn
			;in this case, theEntity does not have any existing xData, so we will simply append the 
			; new xData
			;(princ "there is no existing xData")(princ "\n.\n")
			(setq theEntity
			  (cons newXData theEntity)
			) 
		)
	)
	; Write the newly modified entity to the database.
	(entmod theEntity)
	
	(setq returnValue newRank)
	returnValue
)
	
;========================



(defun C:getRankOfNestedEntity
	(

	/
		ename
		entity
		entityType
		x
	)
	
	(setq x (nentsel "Click on the entity whose rank you want to know.\n"))
	(setq ename (car x))
	(setq nestingDepth (length (last x)))
	(setq entity (entget ename))
	(setq entityType (cdr (assoc 0 entity)))
	
	(princ "\n")
	(princ 
		(strcat
			"type: " entityType "."  "\t" "\n"
			"nestingDepth: " (itoa nestingDepth) "."  "\t" "\n"
			"rank: "
		)
	) 
	(princ (getRank ename)) (princ "\n")
	(princ ".")
	(princ "\n")
	(princ)
)
;========


;;These are some useful commands for fixing the rank of closet doors en mass.
(defun C:setRankOfNestedEntity
	(

		/
		ename
		entity
		entityType
		x
		originalRank
		newRank
		defaultNewRank
	)
	
	(setq x (nentsel "Click on the polyline or circle whose rank you want to set.\n"))
	(setq ename (car x))
	(setq nestingDepth (length (last x)))
	(setq entity (entget ename))
	(setq entityType (cdr (assoc 0 entity)))
	(setq originalRank (getRank ename))
	
	(setq defaultNewRank originalRank)
	; ; (setq newRank (getint (strcat "What rank would you like the new rank to be?  <" (itoa defaultNewRank) ">: ")))
	(setq newRank (getstring T (strcat "What rank would you like the new rank to be?  (enter a sequence of zero or more integers separated by spaces) <" (vl-princ-to-string defaultNewRank) ">: ")))
	
	
	; (if (not newRank) (setq newRank defaultNewRank))
	(if (= 0 (strlen newRank)) 
		(progn
			(setq newRank defaultNewRank)
		)
		(progn
			(if (not (listp (read newRank))) (setq newRank (strcat "(" newRank ")")))
			(setq newRank 
				(read newRank)
			)
		)
	)
	
	;; at this point, newRank is a list whose elements are integers.
	
	
	(if 
		(or
			(= "LWPOLYLINE" entityType)
			(= "CIRCLE" entityType)
		)
		(progn
			(setRank ename newRank)
			(princ "Success! The rank of the selected ")(princ entityType)(princ " is now " )(princ (getRank ename))(princ ".  ")(princ "(it used to be ") (princ originalRank) (princ ").")(princ "\n")
		)

		(progn
			(princ 
				(strcat
					"The selected object was a " entityType ", which is neither a LWPOLYLINE nor a CIRCLE, so we are ignoring it." "\n"
				)line
			)
		)
	)
	(princ)
)
;=====

;; to get the rank of an element manaully:: (getrank (car (entsel)))
;; to set the rank of an element manaully:: (setrank (car (entsel)) (list 1 2 3 4))